// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";

function make(value) {
  if (value >= 1.0 && value <= 5.0) {
    return value;
  }
  
}

function unsafe_make(value) {
  return value;
}

function get(score) {
  return score;
}

var BoundedScore = {
  make: make,
  unsafe_make: unsafe_make,
  get: get
};

function sha256Hash(input) {
  return "sha256_" + input;
}

function getCurrentTimestamp() {
  return Date.now();
}

function validateSignature(_message, signature) {
  return signature.length > 0;
}

function createAttestation(validatorPubkey, questionId, answer, confidence, isMatch) {
  if (validatorPubkey.length === 0) {
    Js_exn.raiseError("Invalid validator key");
  }
  if (confidence < 0.0 || confidence > 1.0) {
    Js_exn.raiseError("Confidence must be between 0.0 and 1.0");
  }
  if ("dummy_signature".length <= 0) {
    Js_exn.raiseError("Hash validation failed");
  }
  return {
          validatorPubkey: validatorPubkey,
          questionId: questionId,
          isMatch: isMatch,
          confidence: confidence,
          timestamp: Date.now()
        };
}

function calculateConsensus(attests) {
  var total = Belt_List.length(attests);
  if (total === 0) {
    return ;
  }
  var matches = Belt_List.length(Belt_List.keep(attests, (function (a) {
              return a.isMatch;
            })));
  var ratio = matches / total;
  var avgConf = Belt_List.reduce(attests, 0, (function (acc, a) {
          return acc + a.confidence;
        })) / total;
  var quorum = avgConf < 0.4 ? 3 : (
      avgConf < 0.8 ? 4 : 5
    );
  var reached = total >= quorum;
  return Belt_MapString.fromArray([
              [
                "consensusReached",
                reached ? 1 : 0
              ],
              [
                "consensusRatio",
                ratio
              ],
              [
                "averageConfidence",
                avgConf
              ],
              [
                "requiredQuorum",
                quorum
              ],
              [
                "totalAttestations",
                total
              ]
            ]);
}

function updateDistributions(transactions, distributions) {
  return Belt_List.reduce(transactions, distributions, (function (acc, tx) {
                return Belt_MapString.set(acc, tx.questionId, tx.confidence);
              }));
}

function detectOutliers(scores) {
  var len = Belt_List.length(scores);
  if (len < 3) {
    return /* [] */0;
  }
  var mean = Belt_List.reduce(scores, 0.0, (function (acc, s) {
          return acc + s;
        })) / len;
  var variance = Belt_List.reduce(scores, 0.0, (function (acc, s) {
          return acc + (s - mean) * (s - mean);
        })) / len;
  var stddev = Math.sqrt(variance);
  return Belt_List.keep(scores, (function (s) {
                return Math.abs((s - mean) / Math.max(stddev, 0.001)) > 3.0;
              }));
}

export {
  BoundedScore ,
  sha256Hash ,
  getCurrentTimestamp ,
  validateSignature ,
  createAttestation ,
  calculateConsensus ,
  updateDistributions ,
  detectOutliers ,
}
/* No side effect */
