// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Blockchain from "./Blockchain.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";

function filePath(userId) {
  return "apstat_state_" + userId + ".json";
}

function serializeAtom(data) {
  try {
    return JSON.stringify(data);
  }
  catch (exn){
    return "";
  }
}

function stateToJson(state) {
  var match = state.profile.archetype;
  var tmp;
  tmp = match === "Explorers" ? "Explorers" : "Other";
  var profileJson = {
    userId: state.profile.userId,
    pubkey: state.profile.pubkey,
    privkey: state.profile.privkey,
    reputation: state.profile.reputation,
    history: Belt_List.toArray(state.profile.history),
    streak: state.profile.streak,
    archetype: tmp,
    seedphrase: state.profile.seedphrase,
    wordList: state.profile.wordList
  };
  var transactionsJson = Belt_List.toArray(Belt_List.map(state.transactions, (function (tx) {
              var match = tx.txType;
              var tmp;
              switch (match) {
                case "Attestation" :
                    tmp = "Attestation";
                    break;
                case "APReveal" :
                    tmp = "APReveal";
                    break;
                case "CreateUser" :
                    tmp = "CreateUser";
                    break;
                
              }
              return {
                      hash: tx.hash,
                      prevHash: tx.prevHash,
                      txType: tmp,
                      questionId: tx.questionId,
                      answerHash: tx.answerHash,
                      answerText: tx.answerText,
                      score: Belt_Option.map(tx.score, Blockchain.BoundedScore.get),
                      attesterPubkey: tx.attesterPubkey,
                      signature: tx.signature,
                      timestamp: tx.timestamp,
                      confidence: tx.confidence,
                      anonymousSig: tx.anonymousSig,
                      nonce: tx.nonce,
                      isMatch: tx.isMatch
                    };
            })));
  return JSON.stringify({
              profile: profileJson,
              transactions: transactionsJson,
              metadata: state.metadata
            });
}

function jsonToState(jsonStr) {
  try {
    var parsed = JSON.parse(jsonStr);
    var profileObj = parsed.profile;
    var match = profileObj.archetype;
    var archetype = match === "Explorers" ? "Explorers" : "Other";
    var profile_userId = profileObj.userId;
    var profile_pubkey = profileObj.pubkey;
    var profile_privkey = profileObj.privkey;
    var profile_reputation = profileObj.reputation;
    var profile_history = Belt_List.fromArray(profileObj.history);
    var profile_streak = profileObj.streak;
    var profile_seedphrase = profileObj.seedphrase;
    var profile_wordList = profileObj.wordList;
    var profile = {
      userId: profile_userId,
      pubkey: profile_pubkey,
      privkey: profile_privkey,
      reputation: profile_reputation,
      history: profile_history,
      streak: profile_streak,
      archetype: archetype,
      seedphrase: profile_seedphrase,
      wordList: profile_wordList
    };
    var transactions = Belt_List.fromArray(Belt_Array.map(parsed.transactions, (function (txObj) {
                var match = txObj.txType;
                var txType;
                switch (match) {
                  case "APReveal" :
                      txType = "APReveal";
                      break;
                  case "Attestation" :
                      txType = "Attestation";
                      break;
                  default:
                    txType = "CreateUser";
                }
                var score = Belt_Option.flatMap(txObj.score, (function (s) {
                        return Blockchain.BoundedScore.make(s);
                      }));
                return {
                        hash: txObj.hash,
                        prevHash: txObj.prevHash,
                        txType: txType,
                        questionId: txObj.questionId,
                        answerHash: txObj.answerHash,
                        answerText: txObj.answerText,
                        score: score,
                        attesterPubkey: txObj.attesterPubkey,
                        signature: txObj.signature,
                        timestamp: txObj.timestamp,
                        confidence: txObj.confidence,
                        anonymousSig: txObj.anonymousSig,
                        nonce: txObj.nonce,
                        isMatch: txObj.isMatch
                      };
              })));
    return {
            TAG: "Ok",
            _0: {
              profile: profile,
              transactions: transactions,
              metadata: parsed.metadata
            }
          };
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: "JSON parsing failed"
          };
  }
}

function integrityCheck(state) {
  var dataStr = stateToJson({
        profile: state.profile,
        transactions: state.transactions,
        metadata: {
          version: state.metadata.version,
          timestamp: state.metadata.timestamp,
          checksum: ""
        }
      });
  var computedHash = Blockchain.sha256Hash(dataStr);
  return computedHash === state.metadata.checksum;
}

var storage = {
  contents: undefined
};

function saveState(state) {
  var dataStr = stateToJson({
        profile: state.profile,
        transactions: state.transactions,
        metadata: {
          version: state.metadata.version,
          timestamp: state.metadata.timestamp,
          checksum: ""
        }
      });
  var checksum = Blockchain.sha256Hash(dataStr);
  var finalState_profile = state.profile;
  var finalState_transactions = state.transactions;
  var finalState_metadata = {
    version: "1.0",
    timestamp: Blockchain.getCurrentTimestamp(),
    checksum: checksum
  };
  var finalState = {
    profile: finalState_profile,
    transactions: finalState_transactions,
    metadata: finalState_metadata
  };
  var serialized = stateToJson(finalState);
  var path = filePath(state.profile.userId);
  storage.contents = Belt_MapString.set(storage.contents, path, serialized);
  return {
          TAG: "Ok",
          _0: undefined
        };
}

function loadState(userId) {
  var path = filePath(userId);
  var data = Belt_MapString.get(storage.contents, path);
  if (data === undefined) {
    return {
            TAG: "Error",
            _0: "State not found for user: " + userId
          };
  }
  var msg = jsonToState(data);
  if (msg.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: "Failed to parse state: " + msg._0
          };
  }
  var state = msg._0;
  if (integrityCheck(state)) {
    return {
            TAG: "Ok",
            _0: state
          };
  } else {
    return {
            TAG: "Error",
            _0: "Integrity check failed - data may be corrupted"
          };
  }
}

function testRoundTrip(state) {
  var match = saveState(state);
  if (match.TAG !== "Ok") {
    return false;
  }
  var loadedState = loadState(state.profile.userId);
  if (loadedState.TAG !== "Ok") {
    return false;
  }
  var loadedState$1 = loadedState._0;
  if (state.profile.userId === loadedState$1.profile.userId && state.profile.reputation === loadedState$1.profile.reputation) {
    return Belt_List.length(state.transactions) === Belt_List.length(loadedState$1.transactions);
  } else {
    return false;
  }
}

function runInvariant11Test() {
  var wordList = [
    "apple",
    "banana",
    "cherry",
    "date"
  ];
  var testProfile_history = {
    hd: "q1",
    tl: {
      hd: "q2",
      tl: {
        hd: "q3",
        tl: /* [] */0
      }
    }
  };
  var testProfile = {
    userId: "test_user_001",
    pubkey: "pub_test_seed",
    privkey: "priv_test_seed",
    reputation: 4.2,
    history: testProfile_history,
    streak: 5,
    archetype: "Explorers",
    seedphrase: "test seed phrase",
    wordList: wordList
  };
  var testTransaction_answerHash = "answer_hash_001";
  var testTransaction_answerText = "test answer";
  var testTransaction_score = Blockchain.BoundedScore.make(3.5);
  var testTransaction_anonymousSig = "anon_sig_001";
  var testTransaction = {
    hash: "tx_hash_001",
    prevHash: "prev_hash_000",
    txType: "Attestation",
    questionId: "q1",
    answerHash: testTransaction_answerHash,
    answerText: testTransaction_answerText,
    score: testTransaction_score,
    attesterPubkey: "pub_attester_001",
    signature: "sig_001",
    timestamp: 1640995200000.0,
    confidence: 0.85,
    anonymousSig: testTransaction_anonymousSig,
    nonce: 123,
    isMatch: true
  };
  var testState_transactions = {
    hd: testTransaction,
    tl: /* [] */0
  };
  var testState_metadata = {
    version: "1.0",
    timestamp: Blockchain.getCurrentTimestamp(),
    checksum: ""
  };
  var testState = {
    profile: testProfile,
    transactions: testState_transactions,
    metadata: testState_metadata
  };
  var passed = testRoundTrip(testState);
  console.log("Invariant 11 Test (load(save(s)) = s): " + (
        passed ? "PASS" : "FAIL"
      ));
}

export {
  filePath ,
  serializeAtom ,
  stateToJson ,
  jsonToState ,
  integrityCheck ,
  storage ,
  saveState ,
  loadState ,
  testRoundTrip ,
  runInvariant11Test ,
}
/* No side effect */
